<!DOCTYPE html>
<html lang="en">
<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Homework1</title>
		<script type="module" crossorigin="" src="JavaSimulation.js"></script>
		<link rel="stylesheet" crossorigin="" href="Style.css">
</head>

<body>
    <div id="app" data-v-app="">
		<div data-v-7b2a1075="" class="container">
			<div class="hw">
				<h1>Homework 1</h1>
				<h2>Theory</h2>
				<h3>Basic Notions in Statistics</h3>
				<p> In statistics, a <em>population</em> refers to the entire set of 
					individuals or items that we are interested in studying. <br> A <em>statistical unit</em> is a 
					single member of this population. The <em>distribution</em> of a dataset describes 
					how the values are spread or distributed. <br><em>Frequency</em> refers to how often 
					a particular value appears in a dataset. It can be expressed in different forms: <em>absolute frequency</em> is 
					the count of occurrences, <em>relative frequency</em> is the proportion of occurrences
					relative to the total number of observations, and <em>percentage frequency</em> is the
					relative frequency expressed as a percentage. </p>

				<h3>Notion of Arithmetic Average:</h3>
				<p> The arithmetic average, or mean, is a measure of central tendency that is calculated
					by summing all the values in a dataset and dividing by the number of values. However,
					when dealing with floating-point numbers, computational problems such as <em>floating
					-point representation errors</em> and <em>catastrophic cancellation</em> can occur.
					These issues arise due to the limited precision with which computers represent 
					real numbers, leading to inaccuracies in calculations. </p>

				<h3>Numerical Solution (Knuth's Algorithm):</h3>
				<p> To address these computational problems, Knuth's compensated summation algorithm can
				be used. This algorithm improves the accuracy of the sum by keeping a running 
				compensation for lost low-order bits, thereby minimizing the errors that occur 
				during floating-point arithmetic operations. </p>

				<h2>Practice</h2>
				<p> We have n servers with m attackers. The hacker has probability p to penetrate each 
					server. Make a graphical representation (line flat if hacker doesn't penetrate and 
					a jump to 1 if he penetrates), try different n,m,p. At time n we want to count how 
					many reached each level. </p>

				<p> To solve this problem, I simulated the penetration attempts over a series of n 
					timesteps. The approach involves initializing a matrix where each row represents a 
					timestep (or server) and each column represents an attacker. </p>
					
				<p> At each timestep, the attackers try to penetrate the server. If an attacker succeeds,
					the value at the current timestep for that attacker is incremented by 1. This is 
					repeated for each attacker and each timestep up to n. </p>
					
				<p> This is visualized using a line chart where each line represents an attacker's 
					progress over time. Hovering over a point on the line shows the number of successful 
					attempts for that attacker at that timestep. On each timestep, the total number of 
					breaches is calculated by summing the values of all attackers at that timestep. 
					This is shown on the x-axis. </p>
					
				<p> Additionally, a histogram is created to represent the distribution of successes 
					among the attackers at the final timestep. The histogram shows how many attackers 
					achieved each possible number of successes, from 0 to n. The length of each bar in 
					the histogram is proportional to the number of attackers who achieved that number 
					of successes. </p>

				<p>The simulation is run using the following code snippet:</p>
					
				<pre>        
					<code>
          			runSimulation() { const timesteps = [Array.from({ length: this.m }, () =&gt; 0)]  
					<div class="comment">// Initialize the timesteps array with zeros for each attacker</div>
				
					for (let i = 1; i &lt; this.n + 1; i++) {
					timesteps.push(
					timesteps[i - 1].map((value) =&gt; (Math.random() &lt; this.p ? value + 1 : value)) <div class="comment">// Increment the value if the attacker succeeds based on probability p</div>
					)
					}
					this.timesteps = timesteps 
					<div class="comment">// Store the generated timesteps in the component's data</div>
					this.plotTimesteps() 
					<div class="comment">// Plot the results of the timesteps</div>
					this.plotHistogram() 
					<div class="comment">// Ensure this method is called after the simulation to plot the histogram</div>
					}
        			</code>
      			</pre>
	  
				<p> This function initializes the simulation by creating an array of timesteps, where 
				each timestep is an array representing the state of each attacker. For each timestep,
		 		it iterates over the attackers and randomly decides if an attacker successfully 
		 		penetrates the server based on the probability p. If successful, the attacker's 
		 		count is incremented. </p>
		 
				<p> The mean, standard deviation, and mode are calculated 
				based on the final timestep's success values. To ensure numerical stability, 
				Knuth's compensated summation algorithm is used for the mean and standard 
				deviation calculations. </p>
				
				<p> The mean is calculated using a running sum with compensation for lost 
					low-order bits, which helps to minimize floating-point arithmetic errors.</p>
					
				<pre>      
					<code>
        			computeMean(values) { let sum = 0; 
					<div class="comment">// Initialize the sum of values</div>
          			let c = 0; 
					<div class="comment">// A running compensation for lost low-order bits to improve numerical stability</div>
          
          			values.forEach((value) =&gt; {
            		const y = value - c; 
					<div class="comment">// Adjust the current value by subtracting the compensation</div>
            		const t = sum + y; 
					<div class="comment">// Add the adjusted value to the running total</div>
            		c = t - sum - y; 
					<div class="comment"> // Update the compensation for lost low-order bits</div>
            		sum = t; 
					<div class="comment">// Update the sum with the new total</div>
          			});
          
          			return sum / values.length;
        			}
      				</code>
    			</pre>

				<p> The standard deviation is computed using compensation for both the mean 
					and the sum of squares. This way we have a more accurate variance 
					calculation, which becomes important for large datasets. </p>
					
				<pre>        
					<code>
          			computeStandardDeviation(values) {
            		const n = values.length;
            		if (n &lt;= 1) return 0; // 
					<div class="comment">If there's one or no value, standard deviation is 0</div>
            		let mean = 0; // 
					<div class="comment">Initialize mean</div>
            		let M2 = 0;   // 
					<div class="comment">Initialize sum of squares of differences from the mean</div>

            		values.forEach((value, i) =&gt; {
					const delta = value - mean; // 
					<div class="comment">Difference from the current mean</div>
					mean += delta / (i + 1);    // 
					<div class="comment">Update the mean incrementally</div>
					const delta2 = value - mean; // 
					<div class="comment">Difference from the new mean</div>
					M2 += delta * delta2;        // 
					<div class="comment">Update the sum of squares</div>
					});

            		const variance = M2 / (n - 1); // 
					<div class="comment">Calculate sample variance</div>
            		return Math.sqrt(variance);    // 
					<div class="comment">Return the standard deviation</div>
          			}
        			</code>
      			</pre>
	  
	  			<p> The mode is determined by counting the frequency of each success value 
					and identifying the value(s) with the highest frequency. </p>
					
				<div class="input-group">
					<label for="n">Number of servers (n):</label>
					<input type="number" id="n" min="1" step="1">
				</div>
				
				<div class="input-group">
					<label for="m">Number of attackers (m):</label>
					<input type="number" id="m" min="1" step="1">
				</div>
				
				<div class="input-group">
					<label for="p">Probability of penetration (p):</label>
					<input type="number" id="p" min="0" max="1" step="0.01">
				</div>
					
				<div class="run-button-container">
					<button class="run-button"> Run Simulation </button> 
					Attention: the button is disabled for 3 seconds after clicking to prevent the canvas 
					crashing. 
				</div>

				<div class="charts-container">
					<canvas id="timestepsChart" style="box-sizing: border-box; 
					display: block; height: 550px; width: 379px;" width="474" height="687"></canvas>
					<canvas id="histogramChart" style="box-sizing: border-box; 
					display: block; height: 550px; width: 379px;" width="474" height="687"></canvas>
				</div>
			</div>
		</div>
	</div>
  
</body>
